// Code generated by command: go run main.go. DO NOT EDIT.

#include "textflag.h"

// func lz77Asm4kL12V1(base *level1context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm4kL12V1(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 8316(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+4095, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+4095, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+4095, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+4095, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    8316(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 8316(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+4095, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+4095, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 8192(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 8192(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x10, R15
	CMPQ R13, R15
	JG   compareSSE_compare_8_bytes

	// start loop: compare 16 bytes per loop
compareSSE_loop_16_bytes:
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareSSE_not_match_16
	ADDQ     $0x10, R13
	CMPQ     R13, R15
	JLE      compareSSE_loop_16_bytes

	// compare 8 bytes
compareSSE_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareSSE_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareSSE_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareSSE_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13
	JMP  compareSSE_end

compareSSE_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareSSE_end

compareSSE_not_match_16:
	BSFL BP, BP
	ADDQ BP, R13

compareSSE_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 8316(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 10364(R8)
	ADDL $+1, 8192(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 8192(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 9332(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+4095, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm32kL12V1(base *level1context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm32kL12V1(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 8316(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+4095, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+32767, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+4095, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+32767, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    8316(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 8316(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+4095, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+4095, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 8192(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 8192(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x10, R15
	CMPQ R13, R15
	JG   compareSSE_compare_8_bytes

	// start loop: compare 16 bytes per loop
compareSSE_loop_16_bytes:
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareSSE_not_match_16
	ADDQ     $0x10, R13
	CMPQ     R13, R15
	JLE      compareSSE_loop_16_bytes

	// compare 8 bytes
compareSSE_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareSSE_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareSSE_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareSSE_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13
	JMP  compareSSE_end

compareSSE_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareSSE_end

compareSSE_not_match_16:
	BSFL BP, BP
	ADDQ BP, R13

compareSSE_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 8316(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 10364(R8)
	ADDL $+1, 8192(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 8192(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 9332(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+4095, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm4kL12V3(base *level1context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX, AVX2, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm4kL12V3(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 8316(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+4095, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+4095, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+4095, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+4095, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    8316(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 8316(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+4095, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+4095, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 8192(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 8192(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x20, R15
	CMPQ R13, R15
	JG   compareAVX2_compare_16_bytes

	// start loop: compare 32 bytes per loop
compareAVX2_loop_32_bytes:
	VMOVDQU   (R14)(R13*1), Y0
	VMOVDQU   (R9)(R13*1), Y1
	VPCMPEQB  Y1, Y0, Y0
	VPMOVMSKB Y0, BP
	XORL      $0xffffffff, BP
	JNZ       compareAVX2_not_match_32
	ADDQ      $0x20, R13
	CMPQ      R13, R15
	JLE       compareAVX2_loop_32_bytes

	// compare 16 bytes
compareAVX2_compare_16_bytes:
	ADDQ     $0x10, R15
	CMPQ     R13, R15
	JG       compareAVX2_compare_8_bytes
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareAVX2_not_match_32
	ADDQ     $0x10, R13

	// compare 8 bytes
compareAVX2_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareAVX2_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareAVX2_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareAVX2_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13
	JMP  compareAVX2_end

compareAVX2_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareAVX2_end

compareAVX2_not_match_32:
	BSFL BP, BP
	ADDQ BP, R13

compareAVX2_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 8316(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 10364(R8)
	ADDL $+1, 8192(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 8192(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 9332(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+4095, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm32kL12V3(base *level1context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX, AVX2, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm32kL12V3(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 8316(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+4095, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+32767, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+4095, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+32767, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    8316(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 8316(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+4095, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+4095, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 8192(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 8192(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x20, R15
	CMPQ R13, R15
	JG   compareAVX2_compare_16_bytes

	// start loop: compare 32 bytes per loop
compareAVX2_loop_32_bytes:
	VMOVDQU   (R14)(R13*1), Y0
	VMOVDQU   (R9)(R13*1), Y1
	VPCMPEQB  Y1, Y0, Y0
	VPMOVMSKB Y0, BP
	XORL      $0xffffffff, BP
	JNZ       compareAVX2_not_match_32
	ADDQ      $0x20, R13
	CMPQ      R13, R15
	JLE       compareAVX2_loop_32_bytes

	// compare 16 bytes
compareAVX2_compare_16_bytes:
	ADDQ     $0x10, R15
	CMPQ     R13, R15
	JG       compareAVX2_compare_8_bytes
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareAVX2_not_match_32
	ADDQ     $0x10, R13

	// compare 8 bytes
compareAVX2_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareAVX2_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareAVX2_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareAVX2_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13
	JMP  compareAVX2_end

compareAVX2_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareAVX2_end

compareAVX2_not_match_32:
	BSFL BP, BP
	ADDQ BP, R13

compareAVX2_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 8316(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 10364(R8)
	ADDL $+1, 8192(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 8192(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 9332(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+4095, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm4kL12V4(base *level1context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX512BW, BMI, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm4kL12V4(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 8316(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+4095, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+4095, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+4095, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+4095, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    8316(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 8316(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+4095, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+4095, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 8192(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 8192(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	SUBQ $0x40, R15
	CMPQ R13, R15
	JG   compareAVX512_less_than_64_bytes

	// start loop: compare 64 bytes per loop
compareAVX512_loop_64_bytes:
	VMOVDQU8 (R14)(R13*1), Z0
	VMOVDQU8 (R9)(R13*1), Z1
	VPCMPB   $0x04, Z1, Z0, K1
	KTESTQ   K1, K1
	JNZ      compareAVX512_not_match
	ADDQ     $0x40, R13
	CMPQ     R13, R15
	JLE      compareAVX512_loop_64_bytes

compareAVX512_less_than_64_bytes:
	ADDQ       $0x40, R15
	SUBQ       R13, R15
	JLE        compareAVX512_end
	MOVQ       $0xffffffffffffffff, BP
	BZHIQ      R15, BP, BP
	KMOVQ      BP, K1
	VMOVDQU8.Z (R14)(R13*1), K1, Z0
	VMOVDQU8.Z (R9)(R13*1), K1, Z1
	VPCMPB     $0x04, Z1, Z0, K1
	KTESTQ     K1, K1
	JNZ        compareAVX512_not_match
	ADDQ       R15, R13
	JMP        compareAVX512_end

compareAVX512_not_match:
	KMOVQ  K1, BP
	TZCNTQ BP, BP
	ADDQ   BP, R13

compareAVX512_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 8316(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 10364(R8)
	ADDL $+1, 8192(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 8192(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 9332(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+4095, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm32kL12V4(base *level1context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX512BW, BMI, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm32kL12V4(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 8316(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+4095, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+32767, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+4095, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+32767, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    8316(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 8316(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+4095, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+4095, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 9332(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 8192(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 8192(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 9332(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 8192(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	SUBQ $0x40, R15
	CMPQ R13, R15
	JG   compareAVX512_less_than_64_bytes

	// start loop: compare 64 bytes per loop
compareAVX512_loop_64_bytes:
	VMOVDQU8 (R14)(R13*1), Z0
	VMOVDQU8 (R9)(R13*1), Z1
	VPCMPB   $0x04, Z1, Z0, K1
	KTESTQ   K1, K1
	JNZ      compareAVX512_not_match
	ADDQ     $0x40, R13
	CMPQ     R13, R15
	JLE      compareAVX512_loop_64_bytes

compareAVX512_less_than_64_bytes:
	ADDQ       $0x40, R15
	SUBQ       R13, R15
	JLE        compareAVX512_end
	MOVQ       $0xffffffffffffffff, BP
	BZHIQ      R15, BP, BP
	KMOVQ      BP, K1
	VMOVDQU8.Z (R14)(R13*1), K1, Z0
	VMOVDQU8.Z (R9)(R13*1), K1, Z1
	VPCMPB     $0x04, Z1, Z0, K1
	KTESTQ     K1, K1
	JNZ        compareAVX512_not_match
	ADDQ       R15, R13
	JMP        compareAVX512_end

compareAVX512_not_match:
	KMOVQ  K1, BP
	TZCNTQ BP, BP
	ADDQ   BP, R13

compareAVX512_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 8316(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 10364(R8)
	ADDL $+1, 8192(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 8192(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 9332(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+4095, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+4095, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+4095, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm4kL15V1(base *level2context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm4kL15V1(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 65660(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+32767, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+4095, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+32767, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+4095, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    65660(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 65660(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+32767, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+32767, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 65536(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 65536(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x10, R15
	CMPQ R13, R15
	JG   compareSSE_compare_8_bytes

	// start loop: compare 16 bytes per loop
compareSSE_loop_16_bytes:
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareSSE_not_match_16
	ADDQ     $0x10, R13
	CMPQ     R13, R15
	JLE      compareSSE_loop_16_bytes

	// compare 8 bytes
compareSSE_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareSSE_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareSSE_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareSSE_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13
	JMP  compareSSE_end

compareSSE_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareSSE_end

compareSSE_not_match_16:
	BSFL BP, BP
	ADDQ BP, R13

compareSSE_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 65660(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 67708(R8)
	ADDL $+1, 65536(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 65536(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 66676(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+32767, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm32kL15V1(base *level2context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm32kL15V1(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 65660(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+32767, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+32767, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+32767, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+32767, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    65660(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 65660(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+32767, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+32767, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 65536(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 65536(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x10, R15
	CMPQ R13, R15
	JG   compareSSE_compare_8_bytes

	// start loop: compare 16 bytes per loop
compareSSE_loop_16_bytes:
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareSSE_not_match_16
	ADDQ     $0x10, R13
	CMPQ     R13, R15
	JLE      compareSSE_loop_16_bytes

	// compare 8 bytes
compareSSE_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareSSE_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareSSE_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareSSE_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareSSE_not_match_8
	ADDQ $0x08, R13
	JMP  compareSSE_end

compareSSE_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareSSE_end

compareSSE_not_match_16:
	BSFL BP, BP
	ADDQ BP, R13

compareSSE_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 65660(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 67708(R8)
	ADDL $+1, 65536(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 65536(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 66676(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+32767, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm4kL15V3(base *level2context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX, AVX2, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm4kL15V3(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 65660(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+32767, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+4095, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+32767, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+4095, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    65660(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 65660(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+32767, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+32767, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 65536(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 65536(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x20, R15
	CMPQ R13, R15
	JG   compareAVX2_compare_16_bytes

	// start loop: compare 32 bytes per loop
compareAVX2_loop_32_bytes:
	VMOVDQU   (R14)(R13*1), Y0
	VMOVDQU   (R9)(R13*1), Y1
	VPCMPEQB  Y1, Y0, Y0
	VPMOVMSKB Y0, BP
	XORL      $0xffffffff, BP
	JNZ       compareAVX2_not_match_32
	ADDQ      $0x20, R13
	CMPQ      R13, R15
	JLE       compareAVX2_loop_32_bytes

	// compare 16 bytes
compareAVX2_compare_16_bytes:
	ADDQ     $0x10, R15
	CMPQ     R13, R15
	JG       compareAVX2_compare_8_bytes
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareAVX2_not_match_32
	ADDQ     $0x10, R13

	// compare 8 bytes
compareAVX2_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareAVX2_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareAVX2_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareAVX2_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13
	JMP  compareAVX2_end

compareAVX2_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareAVX2_end

compareAVX2_not_match_32:
	BSFL BP, BP
	ADDQ BP, R13

compareAVX2_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 65660(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 67708(R8)
	ADDL $+1, 65536(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 65536(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 66676(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+32767, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm32kL15V3(base *level2context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX, AVX2, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm32kL15V3(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 65660(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+32767, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+32767, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+32767, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+32767, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    65660(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 65660(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+32767, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+32767, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 65536(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 65536(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	XORQ BP, BP
	SUBQ $0x20, R15
	CMPQ R13, R15
	JG   compareAVX2_compare_16_bytes

	// start loop: compare 32 bytes per loop
compareAVX2_loop_32_bytes:
	VMOVDQU   (R14)(R13*1), Y0
	VMOVDQU   (R9)(R13*1), Y1
	VPCMPEQB  Y1, Y0, Y0
	VPMOVMSKB Y0, BP
	XORL      $0xffffffff, BP
	JNZ       compareAVX2_not_match_32
	ADDQ      $0x20, R13
	CMPQ      R13, R15
	JLE       compareAVX2_loop_32_bytes

	// compare 16 bytes
compareAVX2_compare_16_bytes:
	ADDQ     $0x10, R15
	CMPQ     R13, R15
	JG       compareAVX2_compare_8_bytes
	MOVOU    (R14)(R13*1), X0
	MOVOU    (R9)(R13*1), X1
	PCMPEQB  X1, X0
	PMOVMSKB X0, BP
	XORL     $+65535, BP
	JNZ      compareAVX2_not_match_32
	ADDQ     $0x10, R13

	// compare 8 bytes
compareAVX2_compare_8_bytes:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JG   compareAVX2_last_part
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13

	// align to 8 byte and compare
compareAVX2_last_part:
	ADDQ $0x08, R15
	CMPQ R13, R15
	JE   compareAVX2_end
	LEAQ -8(R15), R13
	MOVQ (R14)(R13*1), BP
	XORQ (R9)(R13*1), BP
	JNZ  compareAVX2_not_match_8
	ADDQ $0x08, R13
	JMP  compareAVX2_end

compareAVX2_not_match_8:
	BSFQ BP, BP
	SHRQ $0x03, BP
	ADDQ BP, R13
	JMP  compareAVX2_end

compareAVX2_not_match_32:
	BSFL BP, BP
	ADDQ BP, R13

compareAVX2_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 65660(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 67708(R8)
	ADDL $+1, 65536(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 65536(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 66676(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+32767, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm4kL15V4(base *level2context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX512BW, BMI, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm4kL15V4(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 65660(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+32767, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+4095, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+32767, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+4095, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    65660(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 65660(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+32767, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+32767, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 65536(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 65536(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	SUBQ $0x40, R15
	CMPQ R13, R15
	JG   compareAVX512_less_than_64_bytes

	// start loop: compare 64 bytes per loop
compareAVX512_loop_64_bytes:
	VMOVDQU8 (R14)(R13*1), Z0
	VMOVDQU8 (R9)(R13*1), Z1
	VPCMPB   $0x04, Z1, Z0, K1
	KTESTQ   K1, K1
	JNZ      compareAVX512_not_match
	ADDQ     $0x40, R13
	CMPQ     R13, R15
	JLE      compareAVX512_loop_64_bytes

compareAVX512_less_than_64_bytes:
	ADDQ       $0x40, R15
	SUBQ       R13, R15
	JLE        compareAVX512_end
	MOVQ       $0xffffffffffffffff, BP
	BZHIQ      R15, BP, BP
	KMOVQ      BP, K1
	VMOVDQU8.Z (R14)(R13*1), K1, Z0
	VMOVDQU8.Z (R9)(R13*1), K1, Z1
	VPCMPB     $0x04, Z1, Z0, K1
	KTESTQ     K1, K1
	JNZ        compareAVX512_not_match
	ADDQ       R15, R13
	JMP        compareAVX512_end

compareAVX512_not_match:
	KMOVQ  K1, BP
	TZCNTQ BP, BP
	ADDQ   BP, R13

compareAVX512_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 65660(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 67708(R8)
	ADDL $+1, 65536(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 65536(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 66676(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+32767, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET

// func lz77Asm32kL15V4(base *level2context, input []byte, processed int, offset int, tokens []token, maxToken int) (nOffset int, ntokens []token)
// Requires: AVX512BW, BMI, BMI2, CMOV, MMX+, SSE2, SSE4.2
TEXT ·lz77Asm32kL15V4(SB), NOSPLIT, $8-112
	MOVQ input_base+8(FP), AX
	MOVQ offset+40(FP), BX
	MOVQ processed+32(FP), R10
	SUBQ BX, R10
	SUBQ R10, AX
	ADDQ R10, BX
	MOVQ input_len+16(FP), DX
	SUBQ $+16, DX
	ADDQ R10, DX

	// tokenPtr = &tokens[0]
	MOVQ tokens_base+48(FP), SI

	// maxToken = tokenPtr + maxToken
	MOVQ maxToken+72(FP), DI
	LEAQ (SI)(DI*4), DI

	// tokenPtr = tokenPtr + len(tokens) * 4
	MOVQ  tokens_len+56(FP), R8
	LEAQ  (SI)(R8*4), SI
	MOVQ  base+0(FP), R8
	CMPQ  BX, DX
	JG    input_end
	MOVQ  processed+32(FP), R10
	TESTQ R10, R10
	JNZ   start_main

	// temp := input[offset:offset+8] 
	MOVQ (AX)(BX*1), R11

	// hash = hash4( temp )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// temp = temp & 0xff
	ANDQ $0x000000ff, R11

	// litHist[temp]++
	ADDL $0x01, 65660(R8)(R11*4)
	ORQ  $0x00007800, R11
	MOVL R11, (SI)
	ADDQ $0x00000004, SI
	INCQ BX

start_main:
	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// data = input[offset:offset+8] 
	MOVQ (AX)(BX*1), R9

	// hash = hash4( 0-3 byte )
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// hash2 = hash4( 1-4 byte)
	MOVQ   R9, R12
	SHRQ   $+8, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

loop:
	CMPQ SI, DI
	JG   input_end

	// dist = offset - table[hash]
	MOVQ BX, R12
	DECQ R12
	SUBW (R8)(R10*2), R12

	// table[hash] = offset
	MOVW BX, (R8)(R10*2)

	// offset ++
	INCQ BX

	// hash = hash4( 2-5 byte )
	MOVQ   R9, R13
	SHRQ   $+16, R13
	XORQ   R10, R10
	CRC32L R13, R10
	ANDL   $+32767, R10

	// dist2 = offset - table[hash2]
	MOVQ BX, R15
	DECQ R15
	SUBW (R8)(R11*2), R15

	// table[hash2] = offset 
	MOVW BX, (R8)(R11*2)

	// dist = - (dist & mask)
	ANDQ       $+32767, R12
	NEGQ       R12
	LEAQ       -2(BX)(R12*1), R14
	PREFETCHT0 (AX)(R14*1)

	// hash2 = hash4( 3-6 byte )
	SHRQ   $+24, R9
	XORQ   R11, R11
	CRC32L R9, R11
	ANDL   $+32767, R11

	// dist2 = - (dist2 & mask)
	ANDQ $+32767, R15
	NEGQ R15

	//  data = longdata[:8] 
	//  longdata = longdata[8:] 
	//  len = xor(input[offset - dist:],data) 
	//  if len == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ   X0, R9
	MOVQ   R9, R13
	PSRLDQ $+1, X0
	XORQ   (AX)(R14*1), R13
	JZ     compare_first
	LEAQ   -1(BX)(R15*1), R14

	//  len2 = longdata[:8] 
	//  len2 = xor(input[offset - dist2 :],len2) 
	//  if len2 == 0  { At least the first 8 byte are the same, jump to compare remaining part}
	MOVQ X0, BP
	XORQ (AX)(R14*1), BP
	JZ   compare_second

	// litCode = data & 0xff
	// data >>= 8
	MOVBQZX R9, R14
	SHRQ    $+8, R9

	// if len & 0xffffffff == 0 {  At least the first four bytes are the same, write a len/dist token.  } 
	TESTL $0xffffffff, R13
	JZ    len_dist_pre

	//  longdata = longdata[8:] 
	// hist[lit + 31]++
	PSRLDQ  $+1, X0
	INCL    65660(R8)(R14*4)
	MOVBQZX R9, R12
	TESTL   $0xffffffff, BP
	JZ      lit_and_len_dist_pre
	MOVOU   1(AX)(BX*1), X0
	MOVQ    X0, R9
	ADDQ    $+1, BX

	// hist[lit2 + 31]++
	ADDL $+1, 65660(R8)(R12*4)
	LEAQ 31(R12), R12
	SHLQ $0x0a, R12
	ORQ  R12, R14
	MOVL R14, (SI)
	ADDQ $0x00000004, SI
	CMPQ BX, DX
	JG   input_end
	JMP  loop

lit_and_len_dist_pre:
	// // start to write [lit] and a short [len dist] tokens
	// // now offset point to byte_1
	// len2 = bits.TrailingZeros(len2)
	// len2 = len2 / 8
	BSFQ BP, BP
	SHRQ $+3, BP

	// litCode = token(litCode ,InvalidDist)
	ORQ $0x00007800, R14

	// tokens = append(tokens, litCode)
	MOVL R14, (SI)

	// dist2 = -dist2
	// distCode2 = getDistCode(dist2)
	NEGQ R15
	CMPQ R15, $0x04
	JG   getDistCode_do_compute
	MOVQ R15, R12
	JMP  getDistCode_done

getDistCode_do_compute:
	BSRQ  R15, CX
	DECQ  CX
	BZHIQ CX, R15, R12
	SHRXQ CX, R15, R15
	LEAQ  (R15)(CX*2), R15
	SHLQ  $+9, R12
	ADDQ  R15, R12

getDistCode_done:
	SHLQ $0x0a, R12

	// tempOffset = offset + 1
	// // tempOffset point to byte_2
	LEAQ 1(BX), R13

	// offset += len2
	// if offset > len(input) { goto len_dist_lit_huffman_finish }
	ADDQ BP, BX
	CMPQ BX, DX
	JG   lit_and_len_dist_input_end

	// longdata = input[offset:offset+16]
	MOVOU (AX)(BX*1), X0

	// temp = input[offset:offset+8]
	MOVQ (AX)(BX*1), R14

	// hash3 = hash4( 4-7 byte )
	SHRQ   $+24, R9
	XORQ   R15, R15
	CRC32L R9, R15
	ANDL   $+32767, R15

	// data = temp
	// temp = temp >> 8
	MOVQ R14, R9
	SHRQ $+8, R14

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // compute next 0-4 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// // compute next 1-5 byte hash
	// hash2 = hash4(temp)
	XORQ   R11, R11
	CRC32L R14, R11
	ANDL   $+32767, R11

	// // save byte 4-7 hash to hashtable
	// tempOffset++
	// table[hash3] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R15*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  loop

lit_and_len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R13, (R8)(R10*2)

	// // save byte 3-6 hash to hashtable
	// tempOffset++
	// table[hash2] = tempOffset
	ADDQ $+1, R13
	MOVW R13, (R8)(R11*2)

	// distCode2 =distCode2 + (len2 + 254)
	ADDQ $+254, R12
	ADDQ BP, R12
	ADDL $+1, 66676(R8)(BP*4)
	MOVL R12, 4(SI)
	ADDQ $+8, SI
	SHRQ $0x0a, R12
	ANDQ $+31, R12
	ADDL $+1, 65536(R8)(R12*4)
	JMP  input_end

	// // The case we're dealing with here is just writing a short-length-dist token.
len_dist_pre:
	// len = bits.TrailingZeros(len)/ 8
	BSFQ R13, R13
	SHRQ $+3, R13

len_dist:
	// tempOffset = offset +1
	// // tempOffset == loop_start_offset + 2
	LEAQ 1(BX), R14

	// offset --
	DECQ BX

	// dist = - dist
	NEGQ R12

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_1_do_compute
	MOVQ R12, R15
	JMP  getDistCode_1_done

getDistCode_1_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R15
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R15
	ADDQ  R12, R15

getDistCode_1_done:
	SHLQ $0x0a, R15

	// offset += len
	ADDQ  R13, BX
	CMPQ  BX, DX
	JG    len_dist_input_end
	MOVOU (AX)(BX*1), X0
	MOVQ  (AX)(BX*1), R9
	MOVQ  R9, R12
	SHRQ  $+8, R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)

	// // compute next 0-3 byte hash
	// hash = hash4(data)
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	ADDQ   $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// // compute next 1-4 byte hash
	// hash2 = hash4(data2)
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[len + 254 + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $+10, R15
	ANDQ $+31, R15

	// hist[distCode]++
	ADDL $+1, 65536(R8)(R15*4)

	// // We've set the value of `hash` `hash2` `longdata` `data` and continue the loop
	JMP loop

len_dist_input_end:
	// // save byte 2-5 hash to hashtable
	// table[hash] = temp
	MOVW R14, (R8)(R10*2)
	ADDQ $+1, R14

	// table[hash2] = temp
	MOVW R14, (R8)(R11*2)

	// distCode += len + 254 
	ADDQ $+254, R15
	ADDQ R13, R15

	// tokens = append(tokens,distCode)
	MOVL R15, (SI)
	ADDQ $0x04, SI

	// hist[(len+254) + 31]++
	ADDL $+1, 66676(R8)(R13*4)

	SHRQ $0x0a, R15
	ANDQ $+31, R15

	// hist[distCode ]++
	ADDL $+1, 65536(R8)(R15*4)
	JMP  input_end

compare_first:
	// tempOffset = offset + 1
	LEAQ 1(BX), R9

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R9, (R8)(R10*2)
	ADDQ $+1, R9

	// table[hash2] = tempOffset
	MOVW R9, (R8)(R11*2)

	// prevPtr = &input[prev]
	LEAQ (AX)(R14*1), R14

	// currPtr = &input[offset-1]
	LEAQ -1(AX)(BX*1), R9

	// max = endOfInput + 16 - offset + 1
	LEAQ 17(DX), R15
	SUBQ BX, R15

	// len = 16 * 258
	MOVQ $0x00001020, R13

	// if max > len { max = len}
	CMPQ    R15, $0x00001020
	CMOVQGT R13, R15

	// len = 8
	MOVQ $0x00000008, R13

	// compare(prev,curr,max,len)
	// start comparing
	// check boundary
	SUBQ $0x40, R15
	CMPQ R13, R15
	JG   compareAVX512_less_than_64_bytes

	// start loop: compare 64 bytes per loop
compareAVX512_loop_64_bytes:
	VMOVDQU8 (R14)(R13*1), Z0
	VMOVDQU8 (R9)(R13*1), Z1
	VPCMPB   $0x04, Z1, Z0, K1
	KTESTQ   K1, K1
	JNZ      compareAVX512_not_match
	ADDQ     $0x40, R13
	CMPQ     R13, R15
	JLE      compareAVX512_loop_64_bytes

compareAVX512_less_than_64_bytes:
	ADDQ       $0x40, R15
	SUBQ       R13, R15
	JLE        compareAVX512_end
	MOVQ       $0xffffffffffffffff, BP
	BZHIQ      R15, BP, BP
	KMOVQ      BP, K1
	VMOVDQU8.Z (R14)(R13*1), K1, Z0
	VMOVDQU8.Z (R9)(R13*1), K1, Z1
	VPCMPB     $0x04, Z1, Z0, K1
	KTESTQ     K1, K1
	JNZ        compareAVX512_not_match
	ADDQ       R15, R13
	JMP        compareAVX512_end

compareAVX512_not_match:
	KMOVQ  K1, BP
	TZCNTQ BP, BP
	ADDQ   BP, R13

compareAVX512_end:
	CMPQ R13, $0x00000102
	JLE  len_dist
	JMP  large_len_tokens

compare_second:
	// tempOffset = offset + 1
	LEAQ 1(BX), R12

	// // save byte 2-5 hash to hashtable
	// table[hash] = tempOffset
	MOVW R12, (R8)(R10*2)
	ADDQ $+1, R12

	// table[hash2] = tempOffset
	MOVW    R12, (R8)(R11*2)
	MOVBQZX R9, R9
	ADDL    $+1, 65660(R8)(R9*4)
	ORQ     $0x00007800, R9
	MOVL    R9, (SI)
	ADDQ    $0x04, SI
	MOVQ    X0, R9
	MOVQ    BP, R13
	MOVQ    R15, R12
	ADDQ    $0x01, BX
	JMP     compare_first

large_len_tokens:
	// dist = - dist
	NEGQ R12
	DECQ BX

	// distCode = getDistCode(dist)
	CMPQ R12, $0x04
	JG   getDistCode_2_do_compute
	MOVQ R12, R9
	JMP  getDistCode_2_done

getDistCode_2_do_compute:
	BSRQ  R12, CX
	DECQ  CX
	BZHIQ CX, R12, R9
	SHRXQ CX, R12, R12
	LEAQ  (R12)(CX*2), R12
	SHLQ  $+9, R9
	ADDQ  R12, R9

getDistCode_2_done:
	SHLQ $0x0a, R9

	// lenCode = 258 + 254
	MOVQ $0x00000200, R10

	// lenCode |= distCode
	ORQ R9, R10

	// distance = (distCode >> 10) & 0x1f 
	MOVQ R9, R11
	SHRQ $+10, R11
	ANDQ $+31, R11

	// do{
large_len_tokens_loop:
	// offset += 258
	// hist[31+ 258 + 254]++
	// hist[distance]++
	ADDQ $0x00000102, BX
	ADDL $+1, 67708(R8)
	ADDL $+1, 65536(R8)(R11*4)

	// tokens = append(tokens,token)
	MOVL R10, (SI)
	ADDQ $0x04, SI

	// len -= 258
	SUBQ $+258, R13

	// }while(len >= (258 + 4))
	CMPQ    R13, $0x00000106
	JG      large_len_tokens_loop
	MOVQ    $0x00000102, R10
	CMPQ    R13, $0x00000102
	CMOVQGT R10, R13
	CMPQ    R13, $0x00000004
	CMOVQLT R10, R13
	JL      len_less_than_4

	// distCode |= len
	ORQ  R13, R9
	ADDQ $+254, R9

	// tokens = append(tokens,token)
	MOVL R9, (SI)
	ADDQ $0x04, SI

	// offset += len
	ADDQ R13, BX

	// hist[distance]++
	ADDL $+1, 65536(R8)(R11*4)

	// hist[(len+254)+31]++
	ADDL $+1, 66676(R8)(R13*4)

len_less_than_4:
	LEAQ -4(BX), R9
	LEAQ -8(BX), R10

update_4_hash:
	MOVL   (AX)(R10*1), R11
	MOVL   2(AX)(R10*1), R12
	XORQ   R13, R13
	CRC32L R11, R13
	ANDL   $+32767, R13
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	MOVW   R10, (R8)(R13*2)
	ADDQ   $0x02, R10
	MOVW   R10, (R8)(R11*2)
	ADDQ   $0x02, R10
	CMPQ   R10, R9
	JL     update_4_hash
	CMPQ   BX, DX
	JGE    input_end
	MOVOU  (AX)(BX*1), X0
	MOVQ   (AX)(BX*1), R9
	XORQ   R10, R10
	CRC32L R9, R10
	ANDL   $+32767, R10
	MOVQ   R9, R12
	SHRQ   $0x08, R12
	XORQ   R11, R11
	CRC32L R12, R11
	ANDL   $+32767, R11
	JMP    loop

input_end:
	MOVQ tokens_base+48(FP), AX
	MOVQ AX, ntokens_base+88(FP)
	SUBQ AX, SI
	SHRQ $+2, SI
	MOVQ SI, ntokens_len+96(FP)
	MOVQ tokens_cap+64(FP), AX
	MOVQ AX, ntokens_cap+104(FP)
	MOVQ processed+32(FP), AX
	SUBQ AX, BX
	MOVQ offset+40(FP), AX
	ADDQ AX, BX
	MOVQ BX, nOffset+80(FP)
	RET
